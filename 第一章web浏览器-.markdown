[TOC]

# 第一章 web浏览器

## 1.1 生成HTTP请求消息

### 1.1.1 URL解析

**浏览器中输入网址，浏览器会对网址进行解析，并且根据网址的含义来生成请求信息。**

浏览器是一个具备多种客户端功能的综合性客户端软件，不仅仅可以用来访问web服务器，URL就是来让浏览器来判断它应该使用哪一种功能。

不同的服务器成必须会使用不同的编号，web是80，邮件是25。

`http://lab.glasscom.com/dir1/file.html`,这一个URL会被浏览器进行解析，`http:`表示了访问数据源的机制，也就是协议

`lab.glasscom.com` 表示**web服务器的名称**，`/dir1/file.html` 表示**文件的路径**。

文件有时候可以被省略，那么访问的就是浏览器默认的文件，大多数情况是index.html或者是defalut.htm

`http://www.lab.glasscom.com/` 表示访问叫`/`的目录(目录层级中最顶层的“根目录”)

### 1.1.2 HTTP的基本思路

浏览器会使用**HTPP协议**来访问web服务器。

首先，客户端会向服务器发送请求消息，请求消息包括”对什么“和”进行怎样的操作“两个部分，然后服务器会对请求消息进行解析，然后完成一系列操作，将结果存在响应消息中。

  ”对什么”的部分称为**URI(uniform Resource Identifier)**一般是存放网页的文件名或者是CGI程序的文件名，就是各种访问目标。

  “进行怎样的操作”的部分称为**方法**，表示让web服务器完成怎样的工作，典型的例子包括读取URI表示的数据，或者将客户端输入的数据         发送给URI表示的程序。(Get,Post)

响应消息的开头有一个状态码，用来表示操作的执行结果是成功还是发生了错误，状态码后面就是头字段和网页数据，响应消息会被发送回客户端，浏览器会从消息中读出所需的数据并且显示在屏幕上，**HTTP**的整个工作完成了。

### 1.1.3 生成HTTP请求消息

HTTP消息在格式上具有严格的要求。

请求消息的第一行称为请求行，最开头的方法可以告诉web服务器应该进行怎么样的操作，浏览器的工作状态来确定这样一种方法。

`<方法><空格><URI><空格><HTTP版本>`，结尾需要加上HTTP的版本号。

第二行开始为消息头，消息头的规格中定义了很多项目，如日期，客户端支持的数据类型，语言，压缩格式，客户端和服务器的软件名称和版本，数据有效期和最后更新时间。

消息头之后要加一个完全没有内容的空行，然后写上需要发送的数据（消息体）。（GET不需要，POST会将表单中的信息放在消息体）

### 1.1.4 请求消息后会收到响应消息

发送请求信息之后会收到响应。

响应消息的第一行为状态码和响应短语，反映了请求执行的结果成功还是失败，状态码用来给程序说，响应短语用来给人说。

每个请求消息中只能包含一条URI，所以如果需要获取多个文件，必须对每个文件单独发送一次请求。假如一个网页中还有两个图片，那么一共需要发送三次请求。当网页中包含图片时，会在网页中的相应位置嵌入表示图片的文字标签，在显示文字时，会预留出图片的空间，然后再次访问web服务器来加载图片。

## 1.2 向DNS服务器查询web服务器的ip地址

### 1.2.1 ip地址的基本知识

浏览器能够解析网址并且生成HTTP消息，但需要操作系统中的Socket库来将消息发送到网络中，发送时，必须提供通讯对象的ip地址。 

TCP/IP结构可以看成是一些小的子网，由路由器连接起来组成一个大的网络，子网可以理解成用集线器连接起来的几台计算机。子网由路由器连接起来就形成了网络。类似"xx号xx室"，其中“xx号”称为网络号，“xx室”对应的号码为主机号，这就是IP地址。

发出的消息首先由子网的集线器转发到距离最近的路由器上，然后根据消息的目标地址判断下一个路由器的位置并且转发，直到到达目标

**IP地址** 是32bit的数字，8位为一组，网络号和主机号一共是32位，但是没有明确的区分标准，只能依靠附加信息来表示IP地址的内部结构，这种附加信息被称为子网掩码。**子网掩码**也是32位，左边为1，右边为0，和IP地址对齐后，为1的是网络号，为0的是主机号。

IP地址中主机号全部为0代表的是整个子网，而不是子网中的某台设备；主机号全部为1代表向子网中所有设备发送包，也就是广播。

### 1.2.2 ip地址查询的前奏

TCP/IP网络是通过IP地址来确定通信对象的，所以操作系统发送消息之前，应该查询到相关的ip地址。

**DNS(Domain Name System)**就是一种可以通过ip地址查询到名称，或者是通过名称查询到ip地址的机制，我们需要通过DNS服务器查询ip。对于DNS服务器上，计算机上相当于DNS客户端的程序被称为**DNS解析器**，也叫做解析器。通过DNS查询ip地址的操作被称为**域名解析**。Socket库是操作系统中让其他应用程序调用操作系统的网络功能的库。

### 1.2.3 ip地址查询概览

根据域名查询ip地址时，浏览器会使用Socket库中的解析器。

调用解析器，解析器会向DNS服务器发送查询消息，然后解析器接受返回消息，并将其写入浏览器指定的内存中。

发送消息并不是解析器本身来进行，而是调用操作系统内部的协议栈来进行，调用协议栈后，协议栈会执行发送消息的操作，调用网卡将消息发送给DNS服务器。

接受消息会经过网络到达客户端，经过协议栈被传递到解析器，被写入指定的内存空间。

**DNS服务器的ip地址是作为TCP/IP的设置项目提前设置好的**。

## 1.3 全世界DNS服务器的大接力

### 1.3.1 DNS服务器的基本工作

DNS服务器的基本工作就是接受来自客户端的查询消息，然后根据消息的内容返回响应。

来自客户端的查询消息分布三部分：

1. 域名：服务器，邮件服务器的名称

2. Class：如今只有互联网，所以Class的值永远为IN

3. 记录类型：当类型为A时，表示域名对应的是域名；当类型为MX时，表示域名对应的是邮件客户端。

DNS服务器中保存有记录数据，就是在这些数据中查找，然后对客户端进行响应。

### 1.3.2 域名的层次结构

互联网中存在着无数的服务器，将所有的信息保存在一个DNS服务器中是不可能的。

将所有的信息分布保存在多台DNS服务器中，这些服务器进行接力查询信息。

首先，DNS服务器中保存的信息都是按照域名以分层次的结构来保存的。DNS域名都是用句号来分隔的。

比如：`www.lab.glasscom.com.`这个域名，`com`域的下一层是`glasscom`域，再下一层是`lab`域，再下面才是`www`这个名字。

在DNS服务器存储信息的时候，每一个域都是按照一个整体来进行存储的，不能将一个域分开来存放到多个DNS服务器上，相反的是，一个DNS服务器也可以存放多个域的信息。

再比如：`www.nikkkeibp.co.jp`这个域名，最上层的`jp`代表分配给日本这个国家的域，下边的`co`是日本国内进行分类的域，代表公司，在下边的`nikkeibp`就是分配给某个公司的域，最下层的`www`就是服务器的域。

1.3.3 寻找相应的DNS服务器并获取IP地址

找到DNS服务器中存放的信息的关键就是如何找到我们要访问的web服务器的信息归哪一个DNS服务器管。

首先，负责管理下级域的DNS服务器的ip地址注册到它们的上级DNS服务器中，然后上级DNS服务器的ip地址再注册到更上一级的DNS服务器中，这样就可以通过上级DNS服务器查询到下级DNS服务器的ip地址，也就是可以向下级DNS服务器发送请求。

在`com,jp`上面还有一级域，称为**“根域”**，其实就是域名后面的 一个`.`，只不过有时候被省略了。分配给根域DNS服务器的ip地址仅有13个。

根域DNS的服务器ip地址会保存在任何一个DNS服务器上，这样从任何一个DNS服务器都可以访问到根域的DNS服务器。

根域服务器的相关信息包含在DNS服务器程序的配置文件中了，因此只要安装了DNS服务器程序，这些信息都被自动配置完成了。

查询过程：客户端首先会找到最近的DNS服务器，假设查找`www.lab.glasscom.com`,最近的DNS服务器中没有这一域名对应的信息，随意需要从顶层开始向下查找，最近的DNS服务器中保存了根域DNS服务器的信息，因此客户端查询的消息将会被发送到根域DNS服务器，根域服务器中也没有这个域名，但是可以判断属于`com`下一级，所以根域DNS服务器会返回所管理的`com`域中的DNS服务器的ip,这样一层一层的问下去，就会得到我们需要的答案。

### 1.3.4 通过缓存加快DNS服务器的响应

DNS服务器有一个缓存的功能，每一次查询域名的时候不一定都要从根域名开始查询，如果要查询的域名和信息在缓存中那么会直接从缓存中得到信息。

服务器中缓存的信息会设置一个有效期，当缓存的信息超过有效期的时候数据就会从缓存中删除，防止原信息发生改变。

## 1.4 委托协议栈发送消息

### 1.4.1 数据收发操作概览

知道了ip地址发送消息，需要委托操作内部的协议栈向ip地址发送信息。

不只是浏览器，所有的网络应用程序都可以这样发送消息。

向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。

收发数据过程就是双方建立了一个数据通道，数据连着这条通道进行，数据从一端进入通道，可以从另一端被取出，数据的流通是双向的。

建立通道的关键在于通道两边的出入口，我们称之为套接字。

首先服务器一方创建套接字，等待客户端向该套接字连接管道（服务器程序一般在启动后就创建好套接字并等待客户端连接管道）；管道在连接的时候是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。

发送过程步骤：

1. 创建套接字（创建套接字阶段）

2. 将管道连接到服务器端的套接字上（连接阶段）

3. 收发数据（通信阶段）

4. 断开管道并删除套接字（断开阶段） 

这四个步骤都是由协议栈来完成的。

### 1.4.2 创建套接字阶段

创建套接字也需要的调用Socket库中的组件，访问DNS服务器时我们调用的是gethostbyname程序组件，创建套接字调用的是socket程序组件。

创建完成套接字之后，协议栈会返回一个描述符。计算机中可能会同时存在多个套接字，而描述符就是来类似“号码牌”来区分这些套接字的。当创建套接字后，我们就可以使用这个套接字来进行收发数据了，只要我们出示描述符，协议栈就可以判断出我们希望使用哪一个套接字来进行连接和收发数据。

### 1.4.3 连接阶段：把管道连接上去

需要委托协议栈将客户端创建的套接字和服务器那边的套接字连接起来。

应用程序通过调用Socket库中的connect 程序来进行连接，connect程序需要提供三个参数：描述符，ip地址，端口号。

**描述符**：创建套接字时返回的描述符，connect程序会将程序指定的描述符告诉协议栈，协议栈就知道应该用哪一个描述符来进行连接和收发数据。

**ip地址**：通过DNS服务器查询到，在进行数据交换的时候，双方必须知道对方的ip地址并告知协议栈。

**端口号**：ip地址是为了区分网络中的各个计算机而分配的数值，只需要知道ip地址就可以识别出网络上的某台计算机，但是连接操作对应的对象是套接字，端口就是用来识别具体的套接字的。（描述符是用来在一台计算机内部识别套接字，并不是告诉网络连接                                    一 方的；如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制）。

服务器上的所使用的端口号都是根据应用的种类事先规定好的，比如web是80端口，电子邮件是25端口，只要制定了实现规定好的端口好，就可以连接到相应的服务器程序的套接字。

客户端在创建套接字的时候，协议栈会为这个套接字随机分配一个端口号，接下来当协议栈执行连接操作的时候，会将这个随机分配的端口号通知给服务器。

当调用connect时，协议栈就会执行连接操作，当连接成功后，协议栈会将对方的ip地址和端口号等信息保存在套接字中，就可以开始收发数据。

### 1.4.4 通信阶段：传递消息

使用write 组件发送消息，调用write时，需要指定描述符和发送数据，由于套接字中已经保存了已连接的通信对象的相关信息(connect)，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送信息

使用read 组件接收消息，调用read时需要指定用于接受到相应消息的内存地址，这一内存地址被称为接收缓冲区，接受缓冲区是一块位于应用程序内部的内存空间。

### 1.4.5 断开阶段：收发数据结束

调用close组件进入断开阶段，最终连接在套接字之间的管道会被断开，套接字本身也会被删除。

web使用HTTP协议规定，当web服务器发送完成响应消息之后，应该主动执行断开操作，因此web服务器会首先调用close来断开连接。断开消息传到客户端之后，客户端的套接字也会进入断开阶段，当浏览器调用read时，read会告知浏览器通道断开，浏览器也会进行close。HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接，发送请求消息，接收响应消息，断开的过程。

HTTP 1.1版本就可以一次连接中收发多个请求和响应的方法，当所有的数据请求完的时候，浏览器会主动触发断开连接的操作。

实际上收发消息依靠的是协议栈，网卡驱动，网卡。

```
<内存地址> = gethostbyname("www.lab.glasscom.com");
<描述符> = socket(<使用IPv4>, <流模式>, ...);
connect(<描述符>, <服务器的ip地址和端口号>, ...);
write(<描述符>, <发送数据>, <发送数据长度>);
<接受数据长度> = read(<描述符>, <接受缓冲区>, ...);
close(<描述符>);
...
```



