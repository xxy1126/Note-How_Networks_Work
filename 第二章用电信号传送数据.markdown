[TOC]

# 第二章 用电信号传输 TCP/IP 数据

## 2.1 创建套接字

### 2.1.1 协议栈内部操作

TCP/IP软件采用分层结构。

最上面一层是网络应用程序，下面接着是Socket库（包含解析器等）。

再下面就是操作系统中的协议栈，协议栈的上半部分分为两块，分别是负责用TCP协议收发数据的部分和用UDP协议收发数据的部分，（像浏览器，邮件等一般应用程序收发数据时用TCP，DNS查询等收发较短的数据时用UDP）。下面一半是用IP协议控制网络包收发操作的部分，IP中还包括ICMP协议和ARP协议。ICMP协议用于告知网络包传送过程中产生的错误以及各种控制消息，ARP协议用于根据IP地址查询相应的以太网MAC地址。

IP下面的网卡驱动程序负责控制网卡硬件，最下面的网卡则负责完成实际的收发操作。

### 2.1.2 套接字的实体就是通信控制信息

**套接字的实体实际上就是通信控制信息。**

在协议栈的内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的控制信息，如：通信对象的ip地址，端口号，通信操作的进行状态等，协议栈是根据套接字中记录的控制信息来工作的。

windows系统中`netstat` 命令可用于显示套接字内容。

139端口是windows文件服务器使用的端口，当本地ip地址和远程ip地址均为0.0.0.0，这表示通信还没开始，ip地址不确定。

### 2.1.3 调用socket时的操作

浏览器委托协议栈使用TCP协议来进行收发数据。

协议栈根据应用程序的申请来执行创建套接字的操作。

协议栈首先会分配一个用来存放套接字的内存空间，并且写入初始状态的控制信息，创建套接字的工作就完成了。

由于套接字记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取通信相关信息。

## 2.2 连接服务器

### 2.2.1 连接是什么意思

连接实际上是通信双方交换控制信息，在套接字中记录一些必要信息并准备收发数据的过程。

套接字刚刚创建完成的时候里面没有存储任何信息，浏览器会通过DNS服务器查询到服务器的ip地址，端口号默认为80，这些都需要告知协议栈；服务器上也会创建套接字（服务器程序一般会在系统启动的时候就创建好套接字并等待客户端连接），服务器不知道通信对象是谁，所以需要客户端向服务器告知必要的信息，比如“我想和你通信，我的ip地址是xxxxx，端口号是xxxx”

连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据的收发准备，当执行数据收发时，我们还需要一块用来临时存放要收发数据的内存空间，这块内存被称为缓冲区，它也是在连接过程中分配的。

### 2.2.2 负责保存控制信息的头部

控制信息可以分为两类：**第一类是客户端和服务器相互联络时交换的控制信息**，这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程都需要，这些内容在TCP协议中进行了定义，这些字段是固定的。

这些信息会被添加在客户端与服务器之间传递的网络包的开头，在连接阶段，数据收发还没有开始，网络包中没有实际的数据只有控制信息，这些控制信息位于网络包的头部，所以被称为头部。

以太网，ip协议也有自己的控制信息，这些信息也叫头部，为了区分，分别称为TCP头部，以太网头部，ip头部。

**第二类是保存在套接字中，用来控制协议栈操作的信息。**

### 2.2.3 连接操作的实际过程

连接操作通过调用 `connect (<描述符>, <服务器ip地址和端口号>,...)`

上面的调用提供了ip地址和端口号，这些信息会被传送到协议栈中的TCP模块，，然后TCP模块会与服务器处的TCP模块交换控制信息。

首先，客户端创建一个包含表示开始数据收发操作的控制信息的头部，**将头部的SYN标志位设置为1**，接下来TCP模块会将信息传递给IP模块，委托它进行发送。IP模块发送之后，服务器的IP模块会将接受到的信息传递给TCP模块，TCP模块根据端口号确定套接字，当确定套接字之后，就会将相应的信息写入套接字，并将套接字的状态改为正在连接。同样的，服务器的TCP模块也会创建一个头部，SYN控制位设置为1，向客户端发送消息，消息的头部中ACK控制位应该设置为1，表示已经接受到相应的网络包。客户端接受到返回消息时，会通过TCP头部来确定是否连接成功，如果SYN标志位为1，表示连接成功。这时候向套接字中写入服务器端的ip地址端口号等，同时将状态改为连接完毕。最后客户端还会将ACK比特设置为1发回服务器，告诉服务器刚才的响应已经收到。

**总体来说一共要发送三次信息，客户端向服务器发送一次，服务器返回一次，最后客户端再向服务器发送一次确定收到响应信息。**

## 2.3 收发数据

### 2.3.1 将HTPP请求消息交给协议栈

数据收发操作是由应用程序调用write将发送的数据交给协议栈，执行发送操作。

协议栈会把收到的数据先存到缓存区，等到一定数量再进行发送，根据以下几个要素判断什么时候发送。

第一是每个网络能够容纳的数据长度，协议栈根据**MTU(Maximum Transmission Unit)**参数来进行判断，在以太网中一般是1500字节，MTU是包含头部的数据长度，**MSS(Maximum Segment Size)**是去除头部之后，一个网络包所能容纳的TCP数据的最大长度。

第二是时间，当应用程序发送频率不高时，为了避免等待时间过长，协议栈会在经历一段时间后，即使没有达到MSS，也会发送。



不同种类和版本的操作系统在相关操作上也就存在差异。像浏览器这种会话型的应用程序在向服务器发送数据时，一般会选择直接发送。

### 2.3.2 对较大的数据进行拆分

当发送缓冲区中的数据超过MSS的长度，其中的数据会被以MSS长度为单位进行分割，拆分出来的每一块都会被单独放进网络包中。

IP模块会在网络包前面添加IP头部和以太网的MAC头部后发送网络包。

### 2.3.3 使用ACK号确认网络包已收到

TCP具备确认对方是否成功收到网络包，已经当对方没收到时进行重发的功能，在发送网络包后，还需要进行确认操作。

原理：TCP模块在拆分数据的时候，会计算好当前的数据块相当于原数据的第几个字节，发送数据的时候，将算好的字节写在TCP头部，被称为**“序号“**，发送数据的长度也需要告知对方，这个不保存在TCP头部中，而是根据网络包的长度减去头部的长度计算出来的，这样我们就知道一个网络包发送的数据是从哪一个字节开始长度是多少了。

通过上面的消息，接收方可以检查网络包是否有遗漏，如果没有遗漏就会将目前收到的数据长度加起来，计算出一共收到了多少个字节，将这个值写入TCP头端的ACK号中发送给发送方（**返回ACK号时，除了设置ACK号之外，还需要将控制位中的ACK比特设为1，这代表ACK号字段有效，接收方也就可以知道这个网络包是用来告知ACK号的）**。

实际上，为了安全起见，序号是随机的，因此在收发数据之前将初始值告诉对方，这个过程在连接过程中完成。连接操作中有一个将**SYN(Synchrinize)**标志位设置为1的操作，这一个操作就是告诉对方序号的初始值。在SYN设置为1的同时，还需要同时设置序号字段的值，而这个值就代表序号的初始值。

TCP采用这样的方式确认对方是否收到了数据，在得到确认之前，发送的网络包都会保存在发送缓冲区中，如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。因此，网卡，集线器，路由器否没有错误补偿机制，一旦检测到错误直接丢弃相关的包就可以。

如果发生网络中断，服务器宕机等问题，TCP尝试几次无效后，就会强制结束通信，并向应用程序报错。

通过”序号“和”ACK号“可以确认接收方是否收到了网络包。

### 2.3.4 提高数据发送数据的方法

**根据网络包的平均往返时间调整ACK号等待时间**

返回ACK号的等待时间（这个时间叫超时时间），当网络拥堵的时候就会发生拥塞，ACK号的返回会变慢，这是我们就必须将等待时间设置的稍微长一点。TCP采用了动态调整等待时间的方法，这个等待时间根据ACK号返回所需的时间来判断。TCP会在数据发送过程中实时测量ACK号的返回时间。(如果一个包被发送多次，接收方会根据序号判断出这个包是重复的，并不会造成网络异常)。

**使用窗口有效管理ACK号**

每发送一个包等到一个ACK号是简单的，但是效率低下，TCP采用滑动窗口的方式来管理数据发送和ACK号操作。

这样虽然会提高效率，但是可能会出现发送包的频率超过接收方处理能力的情况，这样就会导致接收缓冲区溢出。

首先，接收方需要告诉发送方自己最多能接受多少数据，然后发送房根据这个值对数据发送操作进行控制，这就是滑动窗口的基本思路。接收方会根据TCP头部中的窗口字段将自己能接受的数据量告诉发送方。

能够接受的最大数据量称为窗口大小，是TCP调优参数中非常有名的一个。

**ACK与窗口的合并**

发送ACK确定收到数据应该是收到数据确认没有问题之后，而更新窗口则是接收方从缓冲区取出数据传递给应用程序的时候。

接收方在发送ACK号和更新窗口的时候，并不会马上把包发送出去，而是等待一段时间，在这个时间段很有可能出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送。

### 2.3.5 接收HTTP响应消息

浏览器在委托协议栈发送请求消息之后，就会调用read来接收响应消息，响应消息会被存放在接受缓冲区中。由于响应消息可能不会立马返回，而这时候接收缓冲区并没有数据，协议栈会将read的程序暂时挂起，等到有数据进入缓冲区的时候在进行调用。

接收消息之后，协议栈会检查收到的数据块是否完整，如果没有问题，就返回响应的ACK号，然后将数据暂时存放进接收缓冲区，将数据块连接起来，还原出原始数据， 放进应用程序指定的内存空间中，协议栈还需要找到合适的时机 发送窗口更新消息。

## 2.4 从服务器断开并删除套接字 

### 2.4.1 数据发送完毕后断开连接

协议栈在设计上允许任何一段先断开连接。

以服务器端先断开连接为例，服务器调用close程序，协议栈会生成包含断开信息的TCP头部，会向客户端发送一个网络包，TCP头部的FIN标志位置为1，标志着要断开连接，同时套接字也会被标记为断开连接。客户端收到FIN位为1的网络包之后，为了告诉服务器端收到，需要向服务器端发送ACK号来确认。然后客户端的协议栈会将自己的套接字标记为进入断开操作状态。

当应用程序调用read读取信息的时候，协议栈不会向应用程序传递信息，而是告诉应用程序来自服务器的数据已经全部收到了。随后，客户端的协议栈也会发送一个FIN位为1的TCP包，一段时间后，服务器就会返回ACK号。

### 2.4.2 删除套接字

通信结束之后，套接字不会被立即删除，而是等待一段时间后，为的是防止误删。

举个例子：

```
1. 客户端发送FIN
2. 服务器返回ACK号
3. 服务器发送FIN
4. 客户端返回ACK号
```

如果第4步客户端返回的ACK丢失，而客户端已经删除了套接字，套接字中的控制信息被释放，端口号也被释放，假如这时候一个新的通信出现，恰好使用了这个端口，那么当客户端收到服务器再次发送的FIN时，就会把这个刚刚建立的套接字删除。（客户端的端口号是从空闲的端口号中随意选择的）

### 2.4.3 数据收发小节

数据收发操作的第一步是创建套接字，服务器的套接字一般是启动的时候就已经创建完成，客户端则是在需要访问服务器端的时候创建完成套接字并且初始化里面的控制信息。

第二步是连接，首先客户端会向服务器发送一个SYN标志位置为1的TCP包，其中包含了客户端向服务器传送数据时使用的初始序号和客户端接受数据的窗口大小。同时，服务器还会返回一个SYN位为1的TCP包，客户端收到后会返回ACK号，连接阶段完成。

第三步是收发

首先客户端向服务器发送请求消息，TCP会将请求消息按照MSS分割成网络包，每一块加上TCP头部，发送给服务器，TCP头部中包含序号，表示这一个数据块是全部的第几个字节；服务器收到数据包后会返回ACK号；在刚开始的时候，服务器只是不断的接受数据，随着数据收发的不断进行，数据被传给应用程序，缓冲区被释放，服务器还会将新的窗口大小告知客户端。

服务器收到客户端的请求消息后，会向客户端返回响应消息。

第四步就是断开阶段，服务器发送一个FIN为1的TCP包，客户端返回ACK号，然后反过来进行一遍。

## 2.5 IP与以太网的包收发操作 

### 2.5.1 包的基本知识

网络包由头部和数据两部分组成。

首先，发送方的网络设备会负责创建包，生成含有正确控制信息的头部，然后附加数据。

接下来包会被发送到最近的网络转发设备，到达后，转发设备会根据头部的信息判断接下来应该发往哪里，依次接力，包就被发送到终点。

发送方和接收方统称为终端节点。

路由器和集线器是两种不同的转发设备

- 路由器根据目标地址判断下一个路由器的位置。
- 集线器在子网中将包传输到下一个路由器。

实际上，集线器是按照以太网规则传输包的设备，而路由器是按照IP规则传输包的设备，因此可以理解成：

- IP协议根据目标地址判断下一个IP转发设备的位置。
- 子网中的以太网协议将包传输到下一个转发设备。

要访问的服务器的IP放在IP头部，IP协议就可以找到下一个路由器的位置，IP协议会委托以太网协议将包传输过去。这时候，IP协议会查询下一个路由器的以太网地址（MAC地址），并将这个地址写入MAC头部，这样以太网协议就知道要把这一个包发到哪一个位置了。

网络包在传送过程中会经过集线器，集线器是根据以太网协议工作的设备，集线器里有一张用于以太网协议的表，可以根据以太网头部中记录的目的地的信息查出相应的传送方向。接下来，包会到达路由器，路由器在中有一张IP协议的表，可以根据这一张表和IP头部中记录的目的地信息查出下一个路由器 的位置，为了传输包，还需要查到下一个路由器的MAC地址，记录到MAC头部（MAC头部改变，实际上在包到达路由器的时候，MAC头部就会被舍弃，当再次发送的时候又会加上包含新MAC地址的MAC头部）。

以太网可以被替换成无线局域网，ADSL，FTTH等，都可以帮助IP协议传输网络包。

### 2.5.2 包收发操作概览

包收发操作的起点是TCP模块委托IP模块发送包的操作。

这个过程就是TCP模块在数据块的头部加上TCP头部，然后传递给IP模块，传递给IP模块的就是网络包内容。

IP模块会添加IP头部和MAC头部，IP头部中包含IP协议规定的，根据IP地址将包发送所需的控制信息。MAC头部包含通过以太网的局域网将包传输到最近的路由器所需的控制信息。

封装好的网络包交给网络硬件，传递给网络硬件的网络包是一连串的01序列，网络硬件把这些数字信息转换给电信号或光信号，并通过网线或光纤发送出去。

包到达对方的时候接收过程和发送过程是相反的。

TCP模块在收发操作过程中会分为好几个阶段，但是对IP阶段没有影响，IP阶段会把TCP头部和数据块看成一整块二进制数据。

### 2.5.3 生成包含接收方IP地址的IP头部

IP头部包含IP地址，这个地址是由TCP模块告知的。

IP头部中还需要填写发送方的IP地址。IP地址不是分配给计算机的而是分配给网卡的，所以发送方IP地址需要判断发送所使用的网卡，并填写该网卡的IP地址。

由于协议栈的IP模块和路由器中负责收发的部分都是根据IP协议规则来进行包收发操作的，所以他们也都用相同的方法来判断把包发送给谁。这个“IP表”叫做路由表。

目标地址和子网掩码都是0.0.0.0表示默认网关，如果所有其他的ip都无法匹配，就会匹配这一行。

判断出使用哪个网卡之后，还需要填协议号，TCP为0x06,UDP为0x17.

### 2.5.4 生成以太网用的MAC头部

MAC头部的开头是接收方和发送方的MAC地址，大家可以认为它们和IP头部中的接收方和发送方IP地址的功能差不多。

MAC地址是48位。之后是以太类型，0800为IP协议。

网卡本身的MAC地址是在网卡生产的时候写入ROM里的。

IP模块根据路由表Gateway栏判断应该把包发送给谁，但是查到的是IP地址，所以还需要查询MAC地址。

### 2.5.5 通过APR查询目标路由器的MAC地址

**ARP(Address Resolution Protocol) 地址解析协议**

在以太网中，有一种叫做广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是用广播对所以有的设备提问，然后相应的就会有人回答。

网络中存在着ARP缓存的内存空间用来提高查询数据。

一般MAC地址的写法:00-80-C8-2D-82-EA,00:80:C8:2D:82:EA。

将MAC头部加在IP头部前面，整个包就完成了。

如果在交给网卡之前，IP模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了。对于除IP以外其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送操作和发送IP包是完全相同的。这样一来，一张网卡就可以支持各种类型的包。

### 2.5.6 以太网的基本知识

以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计地通信技术。

虽然以太网经历了数次变迁，但是3个基本性质没有变：

- 将包发送到MAC头部地接收方MAC地址代表的目的地
- 用发送方MAC地址识别发送方
- 用协议类型识别包的内容

以太网的基本结构有三种：

- 10BASE5 (以太网原型)
- 采用中继式集线器的变体
- 采用交换式集线器的结构（和上面两种不同，交换式集线器会根据接收方MAC地址将包转发到指定的目的地，因此信号只会到达指定的设备）

以太网和IP一样不会关心包的实际内容，因此以太网的收发操作和TCP的工作状态无关。

### 2.5.7 将IP包转换成电或光信号发送出去

IP生成的网络包只是存放在内存中的一串数字信息，需要转换为电或光信号才可以发送出去。

负责这一操作是网卡，控制网卡是网卡驱动程序。

打开计算机操作系统的时候，网卡驱动程序会对硬件进行初始化操作，网卡会在控制以太网收发操作的MAC模块设置**MAC(Media Address Control)**地址。网卡的ROM保存着全世界唯一的MAC（在生产网卡的时候写入），但是有时候会有不同，比如从命令或者配置文件中读取MAC地址。

### **2.5.8 给网络包再加三个控制数据**

三个控制数据分别是报头，起始帧分界符（SFD），还有末尾的用于检测错误的FCS（帧校验序列），类似CRC(Cyclic Redundancy Check)。

网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区，然后向MAC模块发送发送包的指令。

首先MAC模块会加上三个控制数据，报头的作用是确定包的读取时机，SFD用来确定帧的起始位置。

电信号来表达数字信息的时候就是高低电压来表示01，但是当有连续01的时候就会无法判断分界点，所以最简单的方法就是在数据信号之后再发送一组用来区分比特间距的时钟信号，当时钟信号从下向上变化的时候，读取电压和电流的值。但是这种方法，当距离较远的时候，会发生时间差，也就是时钟信号和数据信号会偏移。

为了解决这个问题，可以将数据信号和时钟信号进行叠加，我们只需要确定频率一定的时钟信号，就可以推断出数据信号，报头就是让我们用来测量时钟信号的。接收方以SFD为分界符，从SFD之后开始提取网络包数据。最后FCS用来检测数据传输过程中由于噪声导致的波声紊乱，数据错误，是一串32位比特的序列。

### 2.5.9 向集线器发送网络包

发送信号的操作分为两种类型，第一种是使用集线器的半双工模式，另一种是使用路由器的全双工模式。

半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号，如果有则需要等待信号发送完毕。如果没有，就可以开始发送信号，首先MAC模块将网络包数字信息按每个比特转换成电信号，然后由PHY或者叫MAU的信号收发模块发送出去。

**在这里，将数字信号转化为电信号的速率就是网络的传输速率**

接下来，PHY模块会将信号转换为可以在网线上传输的格式，并通过网线发射出去（可以理解为PHY模块的功能就是怼MAC模块产生的信号进行格式转换）。

PHY模块还需要监控接收线路中有没有信号进来，在信号开始发送到结束一直没有信号进来那么发送结束。

以太网不会确认发送的信号对方有没有收到，根据以太网的规格，两台设备之间的网线不会超过100米，极少数发生错误，即使发生错误TCP模块也可以搞定。

在集线器使用的半双工模式中，如果两组信号发送碰撞，发送操作就会在终止，为了通知其他设备当前线路发生阻塞，并且还会发送一段时间的阻塞信号，然后所有的发送操作都会停止。一段时间后，网络中的设别会尝试重新发送信号，等待时间会错开，等待时间是根据MAC地址生成的一个随机数计算出来的。每次发生碰撞就会把等待时间延长一倍，10次之后就会报告通信错误。

全双工模式中，发送和接收可以同时进行。

### 2.5.10 接收返回包

接收信号的过程是相反的，PHY模块先开始工作，然后再是MAC模块，MAC从头开始将信号转换为数字信息并存到缓冲区中，当到达数字末尾的时候还需要检查FCS。接下来就需要看MAC头部的接收方地址和网卡在初始化的时候分配给自己的MAC地址是否一致，如果不是自己的包，就直接丢弃。接下来网卡会通知计算机接收到一个包。

通知计算机的操作会使用一个叫做中断的机制。首先网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU中，当产生中断信号的时候，CPU会暂时挂起正在处理的任务，切换到操作系统中断处理程序，然后中断处理程序会调用网卡驱动，控制网卡执行接收操作。（中断，操作系统相关）

网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过MAC头部的以太类型判断协议类型，如果是0x0800就会把包交给TCP/IP协议栈，如果是0x809B，则表示AppleTalk协议，就会把包交给AppleTalk协议栈。

之后协议栈进行操作。

### 2.5.11 将服务器的响应包从IP传递给TCP

假设返回的协议类型是0x0800，那么就会交给TCP/IP协议栈，先是IP模块检查IP头部，确认格式是否正确，如果格式没有问题，下一步就是查看接收方的IP地址，如果接收方的IP地址不是自己的IP地址，那么一定是发生了什么错误。当发生这种错误的时候，IP模块会通过ICMP消息将错误告知发送方。如果接收方IP地址正确，IP协议有一个叫做分片的功能，网线和局域网中只能传输小包，所以如果接受到的包是分片的，那么IP模块会将它们还原成原始的包。分片的包会在IP头部的标记字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待具有相同ID的包全部到达进行拼装，这操作叫做分片重组。

接下来交给TCP，TCP模块会根据IP头部接收方和发送方的IP地址还有TCP头部中的端口号来查找相应的套接字。

## 2.6 UDP协议的收发操作

### 2.6.1 UDP协议

有些程序不使用TCP协议来收发数据，而是使用UDP，比如向DNS服务器查询ip的时候。

为什么TCP协议如此复杂？因为我们需要将数据高效可靠地发送给对方，为了实现可靠，我们就需要确定对方是否收到了我们的数据。

如果数据很短，一个包就可以装下，我们不需要TCP那么复杂的协议也可以高效的重发数据，这就是UDP协议，用来发送简短的数据。如果全部重发的话也只不过是重发一个包。

### 2.6.2 控制用的短数据

UDP不需要TCP那样建立和断开连接的操作，只需要在应用程序获取的数据前面加上UDP头部，然后交给IP发送就可以。

如果出错的时候就会接收不到来自对方的回复，应用程序会注意到这个问题，并且重新发送 一遍数据。

### 2.6.3 音频和视频数据

发送音频和视频数据的时候也会使用UDP协议。

音频和视频数据必须在规定时间内送达，一旦送达晚了，就会错过播放时间，导致声音和图像卡顿。

在这些无需重发数据，或者是重发了也没什么意义的情况下，使用UDP发送数据的效率会更高。



